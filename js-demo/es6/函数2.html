<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>函数的扩展</title>
</head>

<body>
    <div></div>
    <script>
        /*
        ====箭头函数
        */

        // {
        //     // var log = function(val) {
        //     //     return val;
        //     // }

            // var log = val => val;

        //     // var log = (val, key) => val + key; 

        //     // var log = (val, key) => ({name: val, id: key})

            // var log = (val, key) => {
            //     console.log(':',val+key)
            // }

            // var log = (...arr) => arr;

            

            //可以核函数赋值一起用
            // var fn = ({x, y}) => x + '_' + y;

        //     // var log = (...arr) => arr;

        //     // var log = (val, key) => {
        //     //     console.log(':',val+key)
        //     // }

        //     //可以核函数赋值一起用
        //     // var fn = ({x, y}) => x + '_' + y;


        //     // console.log(fn({x: 'xjh', y: 'cool'})) 

        //     // var fn = ([x, y, z]) => x + y + z;

        //     // 箭头函数可以简化代码
        //     // const isEven = n => n % 2 == 0;

        //     // const square = n => n * n;

        //     // console.log(isEven(12)) //true
        //     // console.log(isEven(1)) //false
        //     // console.log(isEven(NaN)) //false

        //     // console.log( square(2)) //4
        //     // console.log( square(NaN)) //NAN

            //简化回调函数
            // let arr  = [1, 2 ,3];


        //     // let newArr = arr.map( val => val%2 === 0 )

        //     // console.log( newArr )

        //     // sort方法

        //     // let arr = [1, 11, 2, 22, 31, 30]

        //     // arr.sort() //默认按照字符串Unicode码点排序

        //     // console.log(arr) // [1, 11, 2, 22, 30, 31]

        //     // arr.sort((a, b) => a - b);
        //     // console.log(arr) // 从小到大 [1, 2, 11, 22, 30, 31]

        //     // arr.sort((a, b) => b - a);
        //     // console.log(arr) // 从大到小 [31, 30, 22, 11, 2, 1]

        //     // var fn = (a, b) => {
        //     //     if (a > b) {
        //     //         return 1;
        //     //     }

        //     //     if (a < b) {
        //     //         return -1;

        //     //     }

        //     //     return 0;
        //     // }

        //     // arr.sort(fn)

        //     // console.log(arr)

        //     // var arrs = [
        //     //   { name: 'Edward', value: 21 },
        //     //   { name: 'Sharpe', value: 37 },
        //     //   { name: 'And', value: 45 },
        //     //   { name: 'The', value: -12 },
        //     //   { name: 'Magnetic' },
        //     //   { name: 'Zeros', value: 37 }
        //     // ];

        //     // arrs.sort( (a, b) => {
        //     //     a.value - b.value;
        //     // })

        //     // console.log(arrs) //无法正常排序

        //     // var items = [
        //     //   { name: 'Edward', value: 21 },
        //     //   { name: 'Sharpe', value: 37 },
        //     //   { name: 'And', value: 45 },
        //     //   { name: 'The', value: -12 },
        //     //   { name: 'Magnetic', value: 0},
        //     //   { name: 'Zeros', value: 37 }
        //     // ];

        //     // var newItems = items.sort(function (a, b) {
        //     //   if (a.value > b.value) {
        //     //     return -1;
        //     //   }
        //     //   if (a.value < b.value) {
        //     //     return 1;
        //     //   }
        //     //   // a 必须等于 b
        //     //   return 0;
        //     // })

        //     // console.log(newItems, items) //正常排序 根据数组中每一项元素的value从小到大排序
        //     // console.log(newItems === items)
        // }

        // {
        //     // 箭头函数注意点
        //     // 函数体内this指向：箭头函数里面根本没有自己的this，而是引用外层的this。


            // 箭头函数注意点

            // 函数体内this指向：箭头函数里面根本没有自己的this，而是引用外层的this。

            // var id = '007' // function log() { // console.log('id:' + this.id) // // setTimeout( () => { // // console.log('id:' + this.id) // // }, 100) // } // log() //007 007

        //     // var id = '007'
        //     // function log() {
        //     //     console.log('id:' + this.id) //007
        //     //     setTimeout( () => {
                    
        //     //         console.log('id:' + this.id) //007
        //     //     }, 100)
        //     // }

        //     // log() //007 //007
        //     // log.call({id: 888}) //666 666 

        //     // var id = 110;
        //     // function log() {
        //     //     console.log('id::::',this.id)
        //     //     setTimeout( function() { //当函数执行时，他的执行环境是window
        //     //         console.log('id::::',this.id)
        //     //     }, 100)
        //     // }


        //     // log() // 110 110

        //     // log.call({id: 666}) //666 110            

        //     // function log() {
        //     //     console.log('id::::',this.id)

        //     //     setTimeout( () => {
        //     //         console.log('id::::',this.id)
        //     //     }, 100)

        //     // }

        //     // var id = 110;
            
        //     // log.call({id: 666}) //666 666  箭头函数的this指向函数定义时所在的对象
        //     //a
        //     // function Time() {
        //     //     this.t1 = 0;
        //     //     this.t2 = 0;

        //     //     setInterval( () => this.t1++, 1000 ); //this指向定义函数时的环境
        //     //     setInterval( function() {                    
        //     //         this.t2 ++ ; //这里的this指向window
        //     //     }, 1000 );
        //     // }

        //     // var tt = new Time();

        //     // setTimeout( () => console.log(tt.t1), 3000) //3
        //     // setTimeout( () => console.log(tt.t2), 3000) //0
        // }

        // {
        //     function log(
        //         args1, 
        //         args2
        //     ) {
        //         console.log(args1+args2)
        //     }
        // }

        // 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列
        // {
        //     console.log(...[1, 2, 3, 4]) //1 2 3 4

        //     //es写法

        //     console.log.apply(console, [1, 2, 3, 4]) //1 2 3 4

        // }

        // {
        //     function push(arr, ...args) {

        //         console.log(...args)  // 2 3 4             

        //         arr.push(...args);

        //         console.log(arr) //[1, 2, 3, 4]
        //     }

        //     push([1], 2, 3, 4)

        // }

        //计算传入和
        // {
        //     var arr = [1, 2, 3, 4] //10

        //     function count(...args) {

        //         let res = 0;
        //         for (var i = 0; i < args.length; i++) {
        //             res = res + args[i];
        //         }

        //         console.log(res)

        //         return res
        //     }
        //     count(1, 2) //3
        // }

        // {
        //     function add(x, y) {

        //         return x + y;
        //     }

        //     let s = add(...[1, 2]);

        //     console.log(s) //10
        // }

        // 当我们有了...运算符，就可以替代原来的apply方法

        //例子1
        // {
        //     // es5写法
        //     function add(x, y, z) {
        //         return x + y + z;
        //     }

        //     let arr = [20, 2, 3];

        //     console.log( add.apply(null, arr) ) 


        //     // es6写法
        //     function add(x, y, z) {
        //         return x + y + z;
        //     }

        //     let arr = [20, 2, 3];

        //     console.log( add(...arr) ) //25
        // }

        // 案例2 取出数组中最小的数
        // {
        //     // es5写法
        //     console.log( Math.max.apply(null, [120, 89, 65, 19]) ) 

        //     //es6写法
        //     console.log(Math.max(...[120, 879, 6565, 90])) //6565
        //     console.log(Math.min(...[120, 879, 6565, 90])) //90

        // }

        // 案例3把一个数组的元素放到另一个数组当中
        // {
        //     //es5
        //     let [a, b] = [[1, 3, 5], [2, 4, 6]];

        //     // let b = {
        //     //     0: 1,
        //     //     1: 3,
        //     //     2: 5,
        //     //     length: 3
        //     // }

        //     let a = [2, 4, 6]

        //     Array.prototype.push.apply(a, b) //不确定a是不是数组，所以尝试用Array.prototype
        //     console.log( a , b)

        //     //es6 ...写法只能是数组，如果是对象就不行
        //     let [a, b] = [[1, 3, 5], [2, 4, 6]];
        //     // let [a, b] = [[1, 3, 5], {0: 2, 1: 4, 2: 6, length: 3}]; //报错
        //     a.push(...b)

        //     console.log( a ) //[1, 3, 5, 2, 4, 6]
        // }

        // 扩展运算符应用
        {

            /*合并数组*/

            // let a1 = [1, 2, 3];
            // let ress = ['a', 'b', ...a1]; //["a", "b", "c", 1, 2, 3]


            // let [arr1, arr2, arr3] = [['a', 'b'], ['c'], ['d', 'e']]


            // // es5
            // let res1 = arr1.concat(arr2, arr3) //["a", "b", "c", "d", "e"]

            // //es6
            // let res2 = [...arr1, ...arr2, ...arr3] //["a", "b", "c", "d", "e"]

            // console.log( res1, res2 )

            /*与解构赋值结合*/
            // var  list = ['a', 'b', 'c', 'd']

            //es5
            // var fir = list[0],
            //     less = list.slice(1);

            // console.log(fir, less) // a ["b", "c", "d"]

            //es6

            // let [first, ...less] = ['a', 'b', 'c', 'd']; //注意：...less只能在最后面

            // console.log(first, less) //a ["b", "c", "d"]

            // let [first, ...less] = []; //当为空数组的时候，first为undefined, less为[]

            // console.log(first, less) //undefined []

            // let [first, ...less] = ['abcdefg']; //当是一个字符串时，first为''

            // console.log(first, less) // abcdefg []

            


        }


    </script>
</body>

</html>